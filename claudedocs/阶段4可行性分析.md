# 阶段4 - Rust迁移顾问（FR-11）可行性分析

## 📊 执行摘要

**可行性评级**: 🟢 **高度可行**（90%）

**关键结论**:
- ✅ 所有必需的基础设施已就位（Phase 3）
- ✅ CLI命令框架已预留实现位置
- ✅ 可直接复用现有组件（CodeSlicer、PromptBuilder）
- ⚠️ 需要适配API接口（用户示例代码与实际实现有差异）
- 🎯 **建议立即实施**，预计2-3小时完成

---

## 1. 需求分析

### 1.1 目标概述

实现"诊断三"建议的C-to-Rust FFI迁移顾问，通过以下三个任务：

| 任务 | 描述 | 复杂度 | 时间估算 |
|------|------|--------|----------|
| **T4.1** | 增强PromptBuilder.buildRustFFIPrompt() | 🟢 简单 | 10分钟 |
| **T4.2** | 实现RustMigrationAdvisor.java | 🟡 中等 | 60分钟 |
| **T4.3** | 集成到RefactorCommand.handleRustMigration() | 🟢 简单 | 30分钟 |

### 1.2 功能需求

**输入**:
- C源文件路径（`-f`/`--file`）
- 函数所在行号（`-l`/`--line`）

**输出**:
Markdown格式的Rust迁移建议，包含：
1. 核心功能描述
2. 惯用Rust重写
3. 关键迁移挑战（错误处理、内存管理、类型映射）
4. FFI安全包装器（可选）

**调用方式**:
```bash
harmony-agent refactor <source-path> --type rust-migration -f bzlib.c -l 234
```

---

## 2. 架构兼容性分析

### 2.1 ✅ 已有基础设施（Phase 3完成）

#### CodeSlicer
- **位置**: `src/main/java/com/harmony/agent/core/ai/CodeSlicer.java`
- **功能**: 提取函数级代码上下文
- **接口**:
```java
public String getContextSlice(Path file, int lineNumber)
```
- **状态**: ✅ 已实现并测试

#### PromptBuilder
- **位置**: `src/main/java/com/harmony/agent/core/ai/PromptBuilder.java`
- **当前方法**:
  - `buildIssueValidationPrompt()`
  - `buildRustFFIPrompt()` - ⚠️ **已存在但未实现**
  - `buildCodeQualityPrompt()`
- **扩展难度**: 🟢 极低，直接添加实现即可

#### LLMProvider架构
- **核心接口**:
```java
public interface LLMProvider {
    LLMResponse sendRequest(LLMRequest request);
    String getProviderName();
    boolean isAvailable();
}
```
- **已有实现**:
  - `OpenAIProvider` (OpenAI GPT模型)
  - `ClaudeProvider` (Anthropic Claude模型)
- **工厂模式**: `ProviderFactory.createDefault()`
- **状态**: ✅ 架构完整且稳定

#### Request/Response模型
```java
// LLMRequest - Builder模式
LLMRequest request = LLMRequest.builder()
    .model("gpt-4")
    .temperature(0.5)
    .maxTokens(3000)
    .addSystemMessage("You are an expert...")
    .addUserMessage(prompt)
    .build();

// LLMResponse
response.getContent()        // Markdown文本
response.getTotalTokens()    // Token使用统计
response.isSuccess()         // 请求状态
```

### 2.2 ✅ CLI命令框架

#### RefactorCommand分析
- **位置**: `src/main/java/com/harmony/agent/cli/RefactorCommand.java`
- **关键发现**:
  - ✅ 命令已存在（picocli框架）
  - ✅ 已支持`--type rust-migration`选项
  - ✅ `handleRustMigration()`方法已预留（RefactorCommand.java:98-144）
  - ⚠️ **当前是TODO实现，需要替换为真实逻辑**

**现有TODO实现**:
```java
private int handleRustMigration(ConsolePrinter printer) throws InterruptedException {
    // TODO: Phase 4 - Implement Rust migration suggestions
    printer.spinner("Generating Rust migration advice...", false);
    Thread.sleep(1500);
    printer.spinner("Generating Rust migration advice", true);

    // ... 静态示例输出 ...
}
```

**需要修改**:
1. 添加`-f/--file`和`-l/--line`选项
2. 实例化`RustMigrationAdvisor`
3. 调用`getMigrationSuggestion()`
4. 输出Markdown建议

#### ConsolePrinter输出API
- **可用方法**:
  - `printer.header()` - 大标题
  - `printer.subheader()` - 小标题
  - `printer.info()` - 信息
  - `printer.success()`/`warning()`/`error()` - 状态消息
  - `printer.keyValue()` - 键值对
  - `System.out.println()` - 直接输出（用于Markdown代码块）

---

## 3. 实现方案设计

### 3.1 推荐架构：直接使用LLMProvider

**方案对比**:

| 方案 | 优势 | 劣势 | 推荐度 |
|------|------|------|--------|
| **A. 复用AiValidationClient** | 保持架构一致 | 为JSON设计（温度0.3），不适合开放式生成 | 🟡 不推荐 |
| **B. 创建GeneralAiClient** | 灵活配置，支持多场景 | 增加架构复杂度 | 🟢 可选 |
| **C. 直接使用LLMProvider** | 简单直接，减少封装层 | 缺少统一缓存 | 🟢🟢 **强烈推荐** |

**推荐方案C**的理由：
1. Rust迁移建议是**高级咨询功能**，不需要严格的JSON验证
2. 每次建议都应该新鲜生成，缓存价值较低
3. 减少不必要的抽象层，保持代码简洁
4. 温度设置为0.5-0.7更适合创意性建议

### 3.2 T4.1: 增强PromptBuilder

**实现位置**: `PromptBuilder.java`（已有占位）

**详细实现**:
```java
/**
 * Rust FFI迁移建议提示词
 * @param codeSlice C函数代码片段
 * @return 结构化提示词
 */
public static String buildRustFFIPrompt(String codeSlice) {
    return String.format(
        """
        You are an expert in C-to-Rust migration and FFI (Foreign Function Interface).
        Analyze the following C function:

        ```c
        %s
        ```

        Provide a detailed migration analysis. Structure your response clearly using Markdown.
        Your response MUST include the following sections:

        1.  **Core Responsibility**: Briefly describe the primary purpose of this C function.
        2.  **Idiomatic Rust Rewrite**: Provide an idiomatic, safe Rust function that *replaces* the C code's logic.
        3.  **Key Migration Challenges**:
            * **Error Handling**: How are C error codes (e.g., return values, errno) mapped to Rust `Result` or `Option`?
            * **Memory Management**: Explain how C's manual `malloc`/`free` or pointer parameters map to Rust's ownership model (e.g., `Vec<u8>`, `String`, `Box`).
            * **Type Mapping**: How do C types (e.g., `char*`, `void*`, structs) map to Rust types?
        4.  **FFI Safety Wrapper** (Optional): If a full rewrite is too complex, provide an `extern "C"` Rust function that acts as a *safe wrapper* around the original C code.

        Focus on practical, actionable advice. Use clear Rust code examples with comments.
        """,
        codeSlice
    );
}
```

**修改点**:
- ✅ 占位方法已存在（PromptBuilder.java:60-72）
- 只需填充实现逻辑

### 3.3 T4.2: 实现RustMigrationAdvisor

**新文件**: `src/main/java/com/harmony/agent/core/ai/RustMigrationAdvisor.java`

**架构设计**:
```java
package com.harmony.agent.core.ai;

import com.harmony.agent.llm.model.LLMRequest;
import com.harmony.agent.llm.model.LLMResponse;
import com.harmony.agent.llm.provider.LLMProvider;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.nio.file.Path;

public class RustMigrationAdvisor {
    private static final Logger logger = LoggerFactory.getLogger(RustMigrationAdvisor.class);

    // Rust迁移需要更高的温度以支持创造性建议
    private static final double RUST_MIGRATION_TEMPERATURE = 0.5;
    private static final int RUST_MIGRATION_MAX_TOKENS = 3000;

    private final LLMProvider llmProvider;
    private final CodeSlicer codeSlicer;
    private final String model;

    /**
     * 构造函数
     * @param llmProvider LLM提供者（OpenAI或Claude）
     * @param codeSlicer 代码切片器（复用Phase 3）
     * @param model 模型名称（如"gpt-4"）
     */
    public RustMigrationAdvisor(LLMProvider llmProvider, CodeSlicer codeSlicer, String model) {
        this.llmProvider = llmProvider;
        this.codeSlicer = codeSlicer;
        this.model = model;

        logger.info("RustMigrationAdvisor initialized with provider: {}, model: {}",
            llmProvider.getProviderName(), model);
    }

    /**
     * 获取Rust迁移建议
     * @param file C源文件路径
     * @param lineNumber 函数所在行号
     * @return Markdown格式的迁移建议
     */
    public String getMigrationSuggestion(Path file, int lineNumber) {
        logger.info("Generating Rust migration suggestion for: {}:{}", file, lineNumber);

        try {
            // 1. 使用CodeSlicer提取代码上下文
            String codeSlice = codeSlicer.getContextSlice(file, lineNumber);
            if (codeSlice.startsWith("[Error:")) {
                return "❌ Error: " + codeSlice;
            }

            // 2. 使用PromptBuilder构建提示词
            String prompt = PromptBuilder.buildRustFFIPrompt(codeSlice);

            // 3. 构建LLM请求
            LLMRequest request = LLMRequest.builder()
                .model(model)
                .temperature(RUST_MIGRATION_TEMPERATURE)
                .maxTokens(RUST_MIGRATION_MAX_TOKENS)
                .addSystemMessage(
                    "You are an expert Rust engineer specializing in C-to-Rust migration and FFI. " +
                    "Provide clear, practical, and actionable advice. " +
                    "Always include concrete Rust code examples with detailed comments."
                )
                .addUserMessage(prompt)
                .build();

            // 4. 发送请求
            LLMResponse response = llmProvider.sendRequest(request);

            // 5. 检查响应
            if (!response.isSuccess()) {
                logger.error("LLM request failed: {}", response.getErrorMessage());
                return "❌ Error: Failed to generate migration suggestion - " + response.getErrorMessage();
            }

            logger.info("Migration suggestion generated successfully ({} tokens)",
                response.getTotalTokens());

            return response.getContent();

        } catch (Exception e) {
            logger.error("Failed to generate Rust migration suggestion", e);
            return "❌ Error: " + e.getMessage();
        }
    }

    /**
     * 检查LLM提供者是否可用
     */
    public boolean isAvailable() {
        return llmProvider.isAvailable();
    }
}
```

**关键设计点**:
- ✅ 直接使用LLMProvider接口（避免过度封装）
- ✅ 温度设置为0.5（平衡创造性和准确性）
- ✅ Token限制3000（足够详细的建议）
- ✅ 复用CodeSlicer和PromptBuilder
- ✅ 完整的错误处理和日志记录

### 3.4 T4.3: 集成到RefactorCommand

**修改文件**: `src/main/java/com/harmony/agent/cli/RefactorCommand.java`

**Step 1**: 添加新选项
```java
@Option(
    names = {"-f", "--file"},
    description = "Source file for Rust migration analysis"
)
private String targetFile;

@Option(
    names = {"-l", "--line"},
    description = "Line number in the file"
)
private Integer lineNumber;
```

**Step 2**: 修改handleRustMigration()方法
```java
private int handleRustMigration(ConsolePrinter printer) {
    try {
        // 验证参数
        if (targetFile == null || lineNumber == null) {
            printer.error("Rust migration requires --file and --line options");
            printer.info("Example: refactor <path> --type rust-migration -f bzlib.c -l 234");
            return 1;
        }

        // 验证文件存在
        Path filePath = Paths.get(sourcePath).resolve(targetFile);
        if (!Files.exists(filePath)) {
            printer.error("File not found: " + filePath);
            return 1;
        }

        // 初始化组件
        ConfigManager configManager = parent.getConfigManager();

        // 创建LLMProvider
        String openaiKey = System.getenv("OPENAI_API_KEY");
        if (openaiKey == null || openaiKey.isEmpty()) {
            openaiKey = configManager.getConfig().getAi().getApiKey();
        }

        String claudeKey = System.getenv("CLAUDE_API_KEY");
        ProviderFactory factory = ProviderFactory.createDefault(openaiKey, claudeKey);

        String providerName = configManager.getConfig().getAi().getProvider();
        LLMProvider provider = factory.getProvider(providerName);

        if (!provider.isAvailable()) {
            printer.error("LLM provider not available. Please configure API keys.");
            return 1;
        }

        // 创建RustMigrationAdvisor
        CodeSlicer codeSlicer = new CodeSlicer();
        String model = configManager.getConfig().getAi().getModel();
        RustMigrationAdvisor advisor = new RustMigrationAdvisor(provider, codeSlicer, model);

        // 显示分析开始
        printer.header("Rust Migration Analysis");
        printer.info("File: " + targetFile);
        printer.info("Line: " + lineNumber);
        printer.info("Provider: " + provider.getProviderName());
        printer.blank();

        // 生成建议
        printer.spinner("Analyzing C code and generating Rust migration advice...", false);
        String suggestion = advisor.getMigrationSuggestion(filePath, lineNumber);
        printer.spinner("Analysis complete", true);

        printer.blank();

        // 输出建议
        if (suggestion.startsWith("❌")) {
            printer.error(suggestion);
            return 1;
        } else {
            System.out.println(suggestion);
            printer.blank();
            printer.success("Migration suggestion generated successfully");
            return 0;
        }

    } catch (Exception e) {
        printer.error("Failed to generate Rust migration suggestion: " + e.getMessage());
        if (parent.isVerbose()) {
            e.printStackTrace();
        }
        return 1;
    }
}
```

**修改范围**:
- ✅ 替换RefactorCommand.java:98-144的TODO实现
- ✅ 添加-f和-l选项到类字段
- ✅ 完整的错误处理和用户友好的提示

---

## 4. API接口适配问题

### 4.1 用户示例代码的问题

**用户提供的示例**:
```java
private final LlmProvider llmProvider; // ❌ 错误：类型名小写
LlmProvider.LLMRequest request = new LlmProvider.LLMRequest(prompt, 0.5, false); // ❌ 错误：构造函数不存在
LlmProvider.LLMResponse response = llmProvider.sendRequest(request); // ❌ 错误：类型名错误
```

### 4.2 正确的实现

```java
// ✅ 正确：接口名是LLMProvider（全大写）
private final LLMProvider llmProvider;
private final CodeSlicer codeSlicer;

// ✅ 正确：使用Builder模式
LLMRequest request = LLMRequest.builder()
    .model("gpt-4")
    .temperature(0.5)
    .maxTokens(3000)
    .addSystemMessage("You are an expert...")
    .addUserMessage(prompt)
    .build();

// ✅ 正确：调用sendRequest
LLMResponse response = llmProvider.sendRequest(request);
String markdownContent = response.getContent();
```

### 4.3 关键差异对照表

| 用户示例 | 实际API | 修正理由 |
|----------|---------|----------|
| `LlmProvider` | `LLMProvider` | 接口命名遵循Java命名规范（首字母大写缩写） |
| `new LlmProvider.LLMRequest(...)` | `LLMRequest.builder()...` | 使用Builder模式，不是直接构造函数 |
| 第3个参数`expectJson` | 不存在此参数 | JSON模式通过系统消息控制，不在Request中 |
| `LlmProvider.LLMResponse` | `LLMResponse` | Response是独立类，不是内部类 |

---

## 5. 风险评估与缓解

### 5.1 技术风险

| 风险 | 概率 | 影响 | 缓解措施 | 状态 |
|------|------|------|----------|------|
| LLM API配置错误 | 低 | 中 | 完善错误提示，检查API密钥可用性 | ✅ 已规划 |
| CodeSlicer提取失败 | 低 | 低 | 已有fallback机制（±10行上下文） | ✅ 已实现 |
| 提示词质量不佳 | 中 | 中 | 参考用户提供的高质量模板，包含few-shot | ✅ 已规划 |
| Markdown输出格式混乱 | 低 | 低 | 在系统消息中明确要求结构化输出 | ✅ 已规划 |
| Token超限 | 低 | 低 | 设置maxTokens=3000，监控使用情况 | ✅ 已规划 |

### 5.2 架构风险

| 风险 | 概率 | 影响 | 缓解措施 | 状态 |
|------|------|------|----------|------|
| 过度封装导致复杂度增加 | 低 | 中 | 选择方案C（直接使用LLMProvider） | ✅ 已决策 |
| 与现有代码冲突 | 极低 | 低 | RefactorCommand已预留实现位置 | ✅ 无冲突 |
| 依赖管理问题 | 极低 | 低 | 所有依赖已在Phase 3添加 | ✅ 无新依赖 |

### 5.3 用户体验风险

| 风险 | 概率 | 影响 | 缓解措施 | 状态 |
|------|------|------|----------|------|
| 命令行参数复杂 | 低 | 低 | 提供清晰的错误提示和使用示例 | ✅ 已规划 |
| AI响应时间过长 | 中 | 中 | 添加spinner动画，显示"正在生成..." | ✅ 已规划 |
| 建议质量不稳定 | 中 | 高 | 使用温度0.5平衡，添加高质量系统提示 | ✅ 已规划 |

---

## 6. 依赖检查清单

### 6.1 Phase 3依赖（已完成）

- [x] **CodeSlicer.java** - 代码切片器
- [x] **PromptBuilder.java** - 提示词构建器（有占位）
- [x] **LLMProvider接口** - LLM提供者抽象
- [x] **LLMRequest/LLMResponse** - 请求/响应模型
- [x] **ProviderFactory** - 提供者工厂
- [x] **OpenAIProvider** - OpenAI实现
- [x] **ClaudeProvider** - Claude实现

### 6.2 新增依赖（无）

**优势**: 无需添加新的Maven依赖，所有必需库已在Phase 3引入。

### 6.3 配置依赖

**需要的配置**:
```yaml
# config.yaml
ai:
  provider: "openai"  # 或 "claude"
  model: "gpt-4"      # 或 "gpt-3.5-turbo" / "claude-3-sonnet"
  api_key: "sk-..."   # 可选，优先使用环境变量
```

**环境变量**（优先级更高）:
- `OPENAI_API_KEY`
- `CLAUDE_API_KEY`

---

## 7. 测试策略

### 7.1 单元测试

**RustMigrationAdvisorTest.java**:
```java
@Test
void testGetMigrationSuggestion_Success() {
    // Mock LLMProvider
    LLMProvider mockProvider = mock(LLMProvider.class);
    when(mockProvider.sendRequest(any()))
        .thenReturn(LLMResponse.builder()
            .content("## Core Responsibility\n...")
            .success(true)
            .build());

    // Test
    RustMigrationAdvisor advisor = new RustMigrationAdvisor(
        mockProvider, new CodeSlicer(), "gpt-4"
    );
    String result = advisor.getMigrationSuggestion(testFile, 10);

    // Verify
    assertThat(result).contains("Core Responsibility");
    verify(mockProvider).sendRequest(argThat(req ->
        req.getTemperature() == 0.5 && req.getMaxTokens() == 3000
    ));
}

@Test
void testGetMigrationSuggestion_CodeSlicerFailure() {
    // Test error handling when CodeSlicer fails
}

@Test
void testGetMigrationSuggestion_LLMFailure() {
    // Test error handling when LLM request fails
}
```

### 7.2 集成测试

**RefactorCommandIntegrationTest.java**:
```java
@Test
void testRustMigrationCommand_EndToEnd() {
    // Setup test file
    Path testFile = createTestCFile();

    // Execute command
    int exitCode = new CommandLine(new HarmonyAgentCLI())
        .execute("refactor", testFile.getParent().toString(),
                 "--type", "rust-migration",
                 "-f", testFile.getFileName().toString(),
                 "-l", "10");

    // Verify
    assertEquals(0, exitCode);
    assertThat(outputCapture.toString())
        .contains("Core Responsibility")
        .contains("Idiomatic Rust Rewrite");
}
```

### 7.3 手动测试场景

1. **正常流程**:
   ```bash
   harmony-agent refactor /path/to/bzip2 --type rust-migration -f bzlib.c -l 234
   ```

2. **错误处理**:
   - 缺少-f或-l参数
   - 文件不存在
   - API密钥未配置
   - LLM服务不可用

3. **边界情况**:
   - 第一行的函数
   - 最后一行的函数
   - 嵌套函数
   - 宏定义

---

## 8. 实施时间估算

### 8.1 任务分解

| 阶段 | 任务 | 时间 | 依赖 |
|------|------|------|------|
| **Phase 1** | T4.1: 实现buildRustFFIPrompt() | 10分钟 | 无 |
| | 单元测试 | 5分钟 | T4.1 |
| **Phase 2** | T4.2: 创建RustMigrationAdvisor.java | 30分钟 | T4.1 |
| | 单元测试 | 20分钟 | T4.2 |
| **Phase 3** | T4.3: 修改RefactorCommand | 20分钟 | T4.2 |
| | 集成测试 | 15分钟 | T4.3 |
| **Phase 4** | 手动测试和调试 | 30分钟 | All |
| | 文档更新 | 15分钟 | All |
| **总计** | | **2小时25分钟** | |

### 8.2 关键路径

```
T4.1 (10min) → T4.2 (30min) → T4.3 (20min) → 测试 (45min) → 文档 (15min)
总计: 2小时20分钟
```

**并行机会**:
- T4.1完成后，单元测试和T4.2开发可部分并行
- T4.2和T4.3的测试编写可并行

---

## 9. 成功标准

### 9.1 功能验收标准

- [ ] 命令`harmony-agent refactor <path> --type rust-migration -f <file> -l <line>`能够成功执行
- [ ] 输出包含4个必需部分：核心功能、Rust重写、迁移挑战、FFI包装器
- [ ] 输出格式为合法的Markdown，可读性良好
- [ ] 错误场景有清晰的错误提示
- [ ] 支持OpenAI和Claude两种提供者

### 9.2 质量标准

- [ ] 代码覆盖率 > 80%（单元测试）
- [ ] 无SonarQube严重问题
- [ ] 日志记录完整（INFO级别用于正常流程，ERROR级别用于异常）
- [ ] 符合项目代码风格（遵循现有命名和结构）

### 9.3 性能标准

- [ ] CodeSlicer响应时间 < 100ms
- [ ] LLM请求超时设置合理（建议60秒）
- [ ] 总响应时间 < 90秒（含LLM处理）

### 9.4 用户体验标准

- [ ] 命令行参数清晰直观
- [ ] 错误消息友好且可操作
- [ ] 进度反馈及时（spinner动画）
- [ ] 输出格式规范，易于复制

---

## 10. 后续优化方向

### 10.1 短期优化（Phase 4.1）

1. **缓存支持**:
   - 为相同函数的建议添加缓存（基于文件路径+行号哈希）
   - 预计节省30-50%的API成本

2. **批量分析**:
   - 支持一次性分析多个函数
   - 命令：`refactor <path> --type rust-migration --batch functions.txt`

3. **配置优化**:
   - 支持自定义温度和token限制
   - 支持选择不同的LLM模型

### 10.2 中期增强（Phase 4.2）

1. **交互式模式**:
   - 用户可对AI建议提问
   - 支持多轮对话改进建议

2. **代码生成**:
   - 自动生成Rust代码文件
   - 生成FFI绑定代码

3. **质量评分**:
   - 对C代码的迁移难度打分
   - 评估迁移后的安全性改进

### 10.3 长期愿景（Phase 5+）

1. **全项目分析**:
   - 扫描整个C项目，生成完整的Rust迁移路线图
   - 识别迁移优先级（高风险函数优先）

2. **增量迁移工具**:
   - 生成FFI桥接代码，支持C和Rust混合编译
   - 自动化测试迁移前后的功能一致性

3. **学习优化**:
   - 基于用户反馈改进提示词
   - 积累常见迁移模式库

---

## 11. 推荐决策

### 11.1 立即实施建议

✅ **强烈推荐立即实施**，理由：

1. **技术可行性极高**（90%）
   - 所有基础设施完备
   - 无新增依赖
   - API接口清晰

2. **商业价值明确**
   - 解决实际痛点（C代码安全性问题）
   - 提供可落地的迁移建议
   - 符合Rust生态趋势

3. **风险可控**
   - 实施时间短（2-3小时）
   - 改动范围小（3个文件）
   - 不影响现有功能

4. **用户体验优秀**
   - CLI命令框架已就绪
   - 输出格式专业（Markdown）
   - 错误处理完善

### 11.2 实施路径

**推荐采用渐进式实施**：

```
Day 1 Morning: T4.1 + T4.2 (核心逻辑)
Day 1 Afternoon: T4.3 + 单元测试
Day 2 Morning: 集成测试 + 手动验证
Day 2 Afternoon: 文档 + 发布
```

### 11.3 关键注意事项

1. **API适配**:
   - ⚠️ 严格按照实际LLMProvider接口实现
   - ⚠️ 不要使用用户示例代码的错误API

2. **错误处理**:
   - ✅ 检查API密钥可用性
   - ✅ 处理CodeSlicer失败场景
   - ✅ 处理LLM请求失败

3. **用户体验**:
   - ✅ 提供清晰的错误提示
   - ✅ 添加spinner动画反馈
   - ✅ 输出格式化的Markdown

---

## 12. 附录

### 12.1 相关文件清单

| 文件路径 | 类型 | 作用 |
|----------|------|------|
| `src/main/java/com/harmony/agent/core/ai/PromptBuilder.java` | 修改 | 添加buildRustFFIPrompt()实现 |
| `src/main/java/com/harmony/agent/core/ai/RustMigrationAdvisor.java` | 新建 | 核心迁移建议服务 |
| `src/main/java/com/harmony/agent/cli/RefactorCommand.java` | 修改 | 替换handleRustMigration()实现 |
| `src/test/java/com/harmony/agent/core/ai/RustMigrationAdvisorTest.java` | 新建 | 单元测试 |
| `src/test/java/com/harmony/agent/cli/RefactorCommandIntegrationTest.java` | 修改 | 集成测试 |

### 12.2 API调用示例

```java
// 完整的调用链示例
Path file = Paths.get("/path/to/bzlib.c");
int line = 234;

// 1. 创建组件
ProviderFactory factory = ProviderFactory.createDefault(openaiKey, claudeKey);
LLMProvider provider = factory.getProvider("openai");
CodeSlicer slicer = new CodeSlicer();
RustMigrationAdvisor advisor = new RustMigrationAdvisor(provider, slicer, "gpt-4");

// 2. 生成建议
String markdown = advisor.getMigrationSuggestion(file, line);

// 3. 输出结果
System.out.println(markdown);
```

### 12.3 预期输出示例

```markdown
## Core Responsibility

This function performs in-place decompression of bzip2-compressed data...

## Idiomatic Rust Rewrite

```rust
use std::io::{self, Read, Write};

pub fn decompress_bzip2(input: &[u8]) -> Result<Vec<u8>, io::Error> {
    // Rust ownership ensures memory safety
    let mut decompressor = bzip2::Decompress::new(false);
    let mut output = Vec::new();

    decompressor.decompress_vec(input, &mut output)?;
    Ok(output)
}
```

## Key Migration Challenges

### Error Handling
- **C approach**: Return codes (0 = success, negative = error)
- **Rust approach**: `Result<Vec<u8>, io::Error>`
  - Eliminates need to check return values
  - Compiler enforces error handling

...
```

---

## 13. 结论

**可行性评级**: 🟢 **高度可行**（90%）

**核心优势**:
1. ✅ 技术栈完整，无缺失组件
2. ✅ CLI框架已预留实现位置
3. ✅ 可直接复用Phase 3成果
4. ✅ 实施时间短，风险可控

**唯一注意事项**:
- ⚠️ 必须使用实际LLMProvider API（不是用户示例代码）
- ⚠️ 需要正确配置API密钥

**推荐行动**:
🚀 **立即开始实施**，按T4.1 → T4.2 → T4.3的顺序渐进完成。

---

**分析日期**: 2025-10-18
**分析者**: Claude Code
**版本**: 1.0
