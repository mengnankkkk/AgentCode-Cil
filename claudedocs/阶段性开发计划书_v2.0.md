# HarmonySafeAgent 详细阶段性开发计划书 v2.0

## 📋 文档信息

- **项目名称：** HarmonySafeAgent
- **项目类型：** Java CLI 安全分析工具
- **文档版本：** 2.0
- **制定日期：** 2025-10-17
- **预计总工期：** 33-44天（约6-9周）

---

## 🎯 项目概述

### 核心目标

开发一个命令行AI Agent工具，用于自动分析鸿蒙系统基础库（如bzip2）的安全性，提供漏洞检测、改进建议生成和安全代码迁移功能。

### 核心价值主张

1. **自动化安全分析**：结合静态分析工具与AI能力，自动识别代码安全问题
2. **智能改进建议**：基于大语言模型提供上下文相关的修复建议
3. **安全代码迁移**：辅助C/C++代码向Rust等内存安全语言迁移
4. **可视化报告**：生成专业的安全分析报告

### 技术架构

```
┌────────────────────────────────────────┐
│          CLI交互层 (Picocli)            │
│   命令解析 │ 参数验证 │ 控制台输出      │
└────────────────────────────────────────┘
                   ↓
┌────────────────────────────────────────┐
│        核心Agent引擎 (Java模块)         │
│  ├── CodeParser (文件扫描与解析)        │
│  ├── SecurityAnalyzer (安全分析引擎)    │
│  ├── DecisionEngine (AI决策引擎)        │
│  ├── CodeGenerator (代码生成器)         │
│  └── ReportGenerator (报告生成)         │
└────────────────────────────────────────┘
         ↓                    ↓
┌──────────────────┐  ┌──────────────────┐
│   AI推理层        │  │  工具链支持层     │
│  OpenAI/DeepSeek │  │  Clang/Semgrep   │
└──────────────────┘  └──────────────────┘
```

### 核心功能命令

| 命令 | 功能 | 优先级 |
|------|------|--------|
| `analyze` | 扫描并分析C/C++/Rust代码安全问题 | P0 |
| `suggest` | 输出AI生成的改进建议与风险评估 | P0 |
| `report` | 输出详细的安全报告 | P1 |
| `refactor` | 自动生成改进或Rust迁移建议 | P2 |
| `config` | 配置API密钥、分析级别等参数 | P0 |

---

## 📊 需求分析

### 功能需求矩阵

| 需求ID | 需求描述 | 优先级 | 复杂度 | 依赖 |
|--------|---------|--------|--------|------|
| FR-01 | CLI命令框架与参数解析 | P0 | ⭐⭐ | 无 |
| FR-02 | 配置管理与持久化 | P0 | ⭐⭐ | FR-01 |
| FR-03 | 代码文件扫描与过滤 | P0 | ⭐⭐ | 无 |
| FR-04 | Clang静态分析集成 | P0 | ⭐⭐⭐⭐ | FR-03 |
| FR-05 | Semgrep规则引擎集成 | P0 | ⭐⭐⭐ | FR-03 |
| FR-06 | 安全问题分类与评级 | P0 | ⭐⭐⭐ | FR-04, FR-05 |
| FR-07 | AI API客户端（OpenAI/DeepSeek） | P0 | ⭐⭐⭐ | FR-02 |
| FR-08 | Prompt工程与结果解析 | P0 | ⭐⭐⭐ | FR-07 |
| FR-09 | 混合分析决策引擎 | P1 | ⭐⭐⭐⭐ | FR-06, FR-08 |
| FR-10 | HTML/Markdown报告生成 | P1 | ⭐⭐ | FR-09 |
| FR-11 | C→Rust迁移建议生成 | P2 | ⭐⭐⭐⭐⭐ | FR-09 |
| FR-12 | 并行分析与增量分析 | P2 | ⭐⭐⭐ | FR-06 |

### 非功能需求

| 类别 | 需求 | 指标 |
|------|------|------|
| 性能 | 分析速度 | 1000行代码 < 10秒 |
| 性能 | 内存使用 | < 512MB |
| 可用性 | CLI响应时间 | < 200ms |
| 可靠性 | AI API成功率 | > 95% |
| 可维护性 | 单元测试覆盖率 | > 80% |
| 安全性 | API密钥加密存储 | AES-256 |
| 兼容性 | 跨平台支持 | Windows/Linux/macOS |

---

## 🚀 详细阶段性开发计划

### 总体时间线

```
阶段0: 项目初始化          [██░░░░░░] 2-3天
阶段1: CLI框架与配置       [████░░░░] 4-5天
阶段2: 静态分析引擎        [██████░░] 6-8天
阶段3: AI增强分析          [█████░░░] 5-7天
阶段4: 代码生成与重构      [███████░] 7-10天 (可降级)
阶段5: 报告生成与可视化    [███░░░░░] 3-4天
阶段6: 性能优化与测试      [████░░░░] 4-5天
阶段7: 容器化与部署        [██░░░░░░] 2-3天
─────────────────────────────────────────────
总计: 33-44天 (6-9周)
```

---

### 📌 阶段0：项目初始化与环境准备

**⏱ 时间估算：** 2-3天
**🎯 目标：** 搭建项目骨架，配置开发环境，验证技术栈可行性

#### 任务分解

| 任务ID | 任务描述 | 工时 | 负责模块 |
|--------|---------|------|---------|
| T0.1 | 创建Maven项目结构 | 0.5天 | 项目框架 |
| T0.2 | 配置POM.xml依赖 | 0.5天 | 依赖管理 |
| T0.3 | 开发环境配置（Java 17, Clang, Semgrep） | 1天 | 环境配置 |
| T0.4 | 技术验证POC（Picocli, Clang调用, AI API） | 1天 | 技术验证 |

#### 技术方案

**项目结构：**
```
HarmonySafeAgent/
├── pom.xml
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/harmony/agent/
│   │   │       ├── Main.java
│   │   │       ├── cli/          (CLI模块)
│   │   │       ├── core/         (核心引擎)
│   │   │       ├── ai/           (AI模块)
│   │   │       ├── utils/        (工具类)
│   │   │       └── config/       (配置管理)
│   │   └── resources/
│   │       ├── templates/        (报告模板)
│   │       ├── rules/            (Semgrep规则)
│   │       └── application.yml
│   └── test/
│       └── java/
├── docs/                          (文档)
├── scripts/                       (构建脚本)
└── README.md
```

**核心依赖（POM.xml）：**
```xml
<dependencies>
    <!-- CLI框架 -->
    <dependency>
        <groupId>info.picocli</groupId>
        <artifactId>picocli</artifactId>
        <version>4.7.5</version>
    </dependency>

    <!-- HTTP客户端 -->
    <dependency>
        <groupId>com.squareup.okhttp3</groupId>
        <artifactId>okhttp</artifactId>
        <version>4.12.0</version>
    </dependency>

    <!-- JSON处理 -->
    <dependency>
        <groupId>com.google.code.gson</groupId>
        <artifactId>gson</artifactId>
        <version>2.10.1</version>
    </dependency>

    <!-- 日志 -->
    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.4.14</version>
    </dependency>

    <!-- 测试 -->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
        <version>5.10.1</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

#### 交付物

- ✅ 可运行的Maven项目骨架
- ✅ 基础CLI命令框架（`--help`, `--version`）
- ✅ 环境配置文档（`docs/setup.md`）
- ✅ POC验证报告

#### 验收标准

- [ ] `mvn clean package` 成功构建JAR包
- [ ] `java -jar target/harmony-agent.jar --help` 显示帮助信息
- [ ] Clang在命令行可调用：`clang --version`
- [ ] Semgrep在命令行可调用：`semgrep --version`
- [ ] OpenAI API测试调用成功

#### 风险与依赖

- **依赖：** 无
- **风险：** 工具安装失败 → 缓解：提供Docker方案

---

### 📌 阶段1：CLI框架与配置模块

**⏱ 时间估算：** 4-5天
**🎯 目标：** 实现完整的CLI交互框架和配置管理系统

#### 任务分解

| 任务ID | 任务描述 | 工时 | 依赖 |
|--------|---------|------|------|
| T1.1 | 实现5个核心命令结构 | 1.5天 | T0.4 |
| T1.2 | 配置文件加载与持久化 | 1天 | - |
| T1.3 | API密钥加密存储 | 0.5天 | T1.2 |
| T1.4 | 控制台输出优化（彩色、进度条） | 1天 | T1.1 |
| T1.5 | 单元测试编写 | 1天 | T1.1-T1.4 |

#### 技术方案

**命令结构实现：**
```java
@Command(name = "harmony-agent",
         mixinStandardHelpOptions = true,
         version = "1.0.0",
         description = "OpenHarmony安全分析工具")
public class HarmonyAgentCLI implements Runnable {

    @Command(name = "analyze", description = "分析源码安全问题")
    public int analyze(
        @Parameters(description = "源码路径") String sourcePath,
        @Option(names = {"-l", "--level"}, defaultValue = "standard",
                description = "分析级别: quick|standard|deep") String level,
        @Option(names = {"-o", "--output"}, description = "输出文件路径") String output
    ) {
        try {
            AnalysisConfig config = new AnalysisConfig(level);
            AnalysisResult result = analysisService.analyze(sourcePath, config);

            if (output != null) {
                reportGenerator.save(result, output);
            } else {
                consolePrinter.print(result);
            }

            return 0;
        } catch (Exception e) {
            logger.error("分析失败", e);
            return 1;
        }
    }

    @Command(name = "config", description = "配置管理")
    public int config(
        @Parameters(index = "0", description = "操作: set|get|list") String action,
        @Parameters(index = "1", arity = "0..1", description = "配置键") String key,
        @Parameters(index = "2", arity = "0..1", description = "配置值") String value
    ) {
        ConfigManager configManager = ConfigManager.getInstance();

        switch (action) {
            case "set":
                configManager.set(key, value);
                System.out.println("✅ 配置已保存: " + key);
                break;
            case "get":
                String val = configManager.get(key);
                System.out.println(key + " = " + val);
                break;
            case "list":
                configManager.list().forEach((k, v) ->
                    System.out.println(k + " = " + maskSensitive(k, v)));
                break;
        }
        return 0;
    }
}
```

**配置文件格式（YAML）：**
```yaml
# ~/.harmony-agent/config.yml
ai:
  provider: openai  # openai | deepseek | claude
  api_key: ${OPENAI_API_KEY}  # 支持环境变量
  model: gpt-4-turbo
  max_tokens: 4096
  temperature: 0.3

analysis:
  level: deep  # quick | standard | deep
  parallel: true
  max_threads: 4
  incremental: false

tools:
  clang_path: /usr/bin/clang
  semgrep_path: /usr/local/bin/semgrep
  rust_path: /usr/bin/rustc

output:
  format: html  # markdown | html | json
  verbose: true
  color: true

cache:
  enabled: true
  ttl: 3600  # 秒
  max_size: 100  # MB
```

**API密钥加密存储：**
```java
public class SecureConfigManager {

    private static final String ALGORITHM = "AES/GCM/NoPadding";
    private static final int KEY_SIZE = 256;

    public void saveApiKey(String apiKey) throws Exception {
        // 从用户名派生密钥
        SecretKey key = deriveKey(System.getProperty("user.name"));

        // 加密
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] encrypted = cipher.doFinal(apiKey.getBytes(StandardCharsets.UTF_8));

        // 保存
        Path configPath = getConfigPath();
        Files.write(configPath, encrypted);

        // 设置文件权限（仅所有者可读写）
        if (!System.getProperty("os.name").toLowerCase().contains("win")) {
            Files.setPosixFilePermissions(configPath,
                PosixFilePermissions.fromString("rw-------"));
        }
    }

    public String loadApiKey() throws Exception {
        SecretKey key = deriveKey(System.getProperty("user.name"));

        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, key);

        byte[] encrypted = Files.readAllBytes(getConfigPath());
        byte[] decrypted = cipher.doFinal(encrypted);

        return new String(decrypted, StandardCharsets.UTF_8);
    }

    private SecretKey deriveKey(String password) throws Exception {
        SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
        KeySpec spec = new PBEKeySpec(password.toCharArray(), getSalt(), 65536, KEY_SIZE);
        SecretKey tmp = factory.generateSecret(spec);
        return new SecretKeySpec(tmp.getEncoded(), "AES");
    }
}
```

**控制台输出优化：**
```java
public class ConsolePrinter {

    private static final String ANSI_RESET = "\u001B[0m";
    private static final String ANSI_RED = "\u001B[31m";
    private static final String ANSI_GREEN = "\u001B[32m";
    private static final String ANSI_YELLOW = "\u001B[33m";

    public void printIssue(Issue issue) {
        String color = switch (issue.getSeverity()) {
            case CRITICAL -> ANSI_RED;
            case HIGH -> ANSI_YELLOW;
            default -> ANSI_RESET;
        };

        System.out.printf("%s%s %s [%s]%s%n",
            color,
            getSeverityIcon(issue.getSeverity()),
            issue.getTitle(),
            issue.getFile() + ":" + issue.getLine(),
            ANSI_RESET
        );
    }

    public void printProgressBar(int current, int total, String task) {
        int percent = (current * 100) / total;
        int completed = percent / 2;

        StringBuilder bar = new StringBuilder("[");
        for (int i = 0; i < 50; i++) {
            bar.append(i < completed ? "█" : "░");
        }
        bar.append("] ").append(percent).append("% - ").append(task);

        System.out.print("\r" + bar);
        if (current == total) {
            System.out.println();
        }
    }
}
```

#### 交付物

- ✅ 完整的CLI命令框架（5个命令）
- ✅ ConfigManager.java（配置管理模块）
- ✅ SecureConfigManager.java（加密存储）
- ✅ ConsolePrinter.java（控制台输出）
- ✅ 单元测试（覆盖率 > 80%）

#### 验收标准

- [ ] 所有命令可执行且参数正确解析
- [ ] `config set openai.key=xxx` 加密保存成功
- [ ] `config get openai.key` 正确解密返回（脱敏显示）
- [ ] 彩色输出在支持的终端正常显示
- [ ] 进度条正常工作
- [ ] 单元测试覆盖率 > 80%

#### 风险与依赖

- **依赖：** 阶段0完成
- **风险：** Windows文件权限设置 → 缓解：使用文件属性API

---

### 📌 阶段2：静态分析引擎

**⏱ 时间估算：** 6-8天
**🎯 目标：** 集成Clang和Semgrep，实现基础安全分析能力

#### 任务分解

| 任务ID | 任务描述 | 工时 | 依赖 |
|--------|---------|------|------|
| T2.1 | 代码文件扫描器实现 | 1天 | - |
| T2.2 | Clang静态分析集成 | 2天 | T2.1 |
| T2.3 | Semgrep规则引擎集成 | 1.5天 | T2.1 |
| T2.4 | 自定义Semgrep规则编写 | 1天 | T2.3 |
| T2.5 | 安全问题分类与评级 | 1.5天 | T2.2, T2.3 |
| T2.6 | 集成测试 | 1天 | T2.1-T2.5 |

#### 技术方案

**代码扫描器：**
```java
public class CodeParser {

    private static final Set<String> SUPPORTED_EXTENSIONS = Set.of(
        ".c", ".cpp", ".cc", ".h", ".hpp", ".rs"
    );

    private static final Set<String> IGNORE_PATTERNS = Set.of(
        "**/node_modules/**",
        "**/build/**",
        "**/dist/**",
        "**/target/**",
        "**/.git/**"
    );

    public List<SourceFile> scanDirectory(String path) throws IOException {
        PathMatcher ignoreMatcher = createIgnoreMatcher();

        return Files.walk(Paths.get(path))
            .parallel()
            .filter(Files::isRegularFile)
            .filter(p -> !ignoreMatcher.matches(p))
            .filter(this::isSupportedFile)
            .map(this::toSourceFile)
            .collect(Collectors.toList());
    }

    private boolean isSupportedFile(Path path) {
        String fileName = path.getFileName().toString();
        return SUPPORTED_EXTENSIONS.stream()
            .anyMatch(fileName::endsWith);
    }
}
```

**Clang集成：**
```java
public class ClangAnalyzer {

    private final String clangPath;

    public AnalysisResult analyze(List<SourceFile> files) throws Exception {
        List<Issue> issues = new ArrayList<>();

        for (SourceFile file : files) {
            // 构建Clang命令
            ProcessBuilder pb = new ProcessBuilder(
                clangPath,
                "--analyze",
                "-Xclang", "-analyzer-output=json",
                "-Xclang", "-analyzer-checker=core,unix,security",
                file.getPath()
            );

            Process process = pb.start();
            String output = readOutput(process);
            int exitCode = process.waitFor();

            if (exitCode == 0 || exitCode == 1) {  // Clang返回1表示发现问题
                List<Issue> fileIssues = parseClangOutput(output, file);
                issues.addAll(fileIssues);
            } else {
                logger.warn("Clang分析失败: " + file.getPath());
            }
        }

        return new AnalysisResult(issues);
    }

    private List<Issue> parseClangOutput(String json, SourceFile file) {
        // 解析Clang JSON输出
        JsonObject root = JsonParser.parseString(json).getAsJsonObject();
        JsonArray diagnostics = root.getAsJsonArray("diagnostics");

        List<Issue> issues = new ArrayList<>();
        for (JsonElement elem : diagnostics) {
            JsonObject diag = elem.getAsJsonObject();

            Issue issue = Issue.builder()
                .type(diag.get("category").getAsString())
                .title(diag.get("description").getAsString())
                .file(file.getPath())
                .line(diag.get("line").getAsInt())
                .severity(mapSeverity(diag.get("level").getAsString()))
                .source("clang")
                .build();

            issues.add(issue);
        }

        return issues;
    }
}
```

**Semgrep集成：**
```java
public class SemgrepAnalyzer {

    private final String semgrepPath;
    private final Path rulesDir;

    public AnalysisResult analyze(String sourcePath) throws Exception {
        // 构建Semgrep命令
        ProcessBuilder pb = new ProcessBuilder(
            semgrepPath,
            "--config", rulesDir.toString(),
            "--json",
            "--quiet",
            sourcePath
        );

        Process process = pb.start();
        String output = readOutput(process);
        int exitCode = process.waitFor();

        if (exitCode != 0 && exitCode != 1) {
            throw new AnalysisException("Semgrep执行失败: " + exitCode);
        }

        return parseSemgrepOutput(output);
    }

    private AnalysisResult parseSemgrepOutput(String json) {
        JsonObject root = JsonParser.parseString(json).getAsJsonObject();
        JsonArray results = root.getAsJsonArray("results");

        List<Issue> issues = new ArrayList<>();
        for (JsonElement elem : results) {
            JsonObject result = elem.getAsJsonObject();

            Issue issue = Issue.builder()
                .type(result.get("check_id").getAsString())
                .title(result.getAsJsonObject("extra").get("message").getAsString())
                .file(result.get("path").getAsString())
                .line(result.get("start").getAsJsonObject().get("line").getAsInt())
                .severity(mapSeverity(result.getAsJsonObject("extra").get("severity").getAsString()))
                .source("semgrep")
                .code(result.getAsJsonObject("extra").get("lines").getAsString())
                .build();

            issues.add(issue);
        }

        return new AnalysisResult(issues);
    }
}
```

**自定义Semgrep规则：**
```yaml
# rules/memory-safety.yml
rules:
  - id: unsafe-strcpy
    pattern: strcpy($DST, $SRC)
    message: "strcpy可能导致缓冲区溢出，建议使用strncpy或snprintf"
    severity: ERROR
    languages: [c, cpp]
    metadata:
      category: memory-safety
      cwe: CWE-120

  - id: unsafe-gets
    pattern: gets($BUF)
    message: "gets函数不检查缓冲区边界，已废弃，使用fgets替代"
    severity: ERROR
    languages: [c, cpp]

  - id: memory-leak
    patterns:
      - pattern: $PTR = malloc(...)
      - pattern-not: free($PTR)
    message: "潜在的内存泄漏：分配后未释放"
    severity: WARNING
    languages: [c, cpp]

  - id: null-deref
    patterns:
      - pattern: $PTR = $FUNC(...)
      - pattern-not: if ($PTR == NULL) { ... }
      - pattern: *$PTR
    message: "潜在的空指针解引用"
    severity: ERROR
    languages: [c, cpp]
```

**安全分析引擎：**
```java
public class SecurityAnalyzer {

    private final ClangAnalyzer clangAnalyzer;
    private final SemgrepAnalyzer semgrepAnalyzer;
    private final ExecutorService executor;

    public AnalysisResult analyze(String sourcePath, AnalysisConfig config) {
        List<Future<AnalysisResult>> futures = new ArrayList<>();

        // 并行执行分析
        futures.add(executor.submit(() -> clangAnalyzer.analyze(sourcePath)));
        futures.add(executor.submit(() -> semgrepAnalyzer.analyze(sourcePath)));

        // 聚合结果
        List<Issue> allIssues = new ArrayList<>();
        for (Future<AnalysisResult> future : futures) {
            try {
                AnalysisResult result = future.get(60, TimeUnit.SECONDS);
                allIssues.addAll(result.getIssues());
            } catch (Exception e) {
                logger.error("分析任务失败", e);
            }
        }

        // 去重
        allIssues = deduplicateIssues(allIssues);

        // 分类与评级
        Map<String, List<Issue>> categorized = categorizeIssues(allIssues);

        return AnalysisResult.builder()
            .issues(allIssues)
            .categorized(categorized)
            .statistics(computeStatistics(allIssues))
            .build();
    }

    private Map<String, List<Issue>> categorizeIssues(List<Issue> issues) {
        return issues.stream().collect(Collectors.groupingBy(issue -> {
            // 分类逻辑
            if (issue.getType().contains("memory")) return "内存安全";
            if (issue.getType().contains("buffer")) return "缓冲区安全";
            if (issue.getType().contains("null")) return "空指针";
            if (issue.getType().contains("leak")) return "资源泄漏";
            return "其他";
        }));
    }
}
```

#### 交付物

- ✅ CodeParser.java（文件扫描模块）
- ✅ ClangAnalyzer.java（Clang集成）
- ✅ SemgrepAnalyzer.java（Semgrep集成）
- ✅ SecurityAnalyzer.java（分析引擎）
- ✅ 10+条自定义Semgrep规则
- ✅ 集成测试用例

#### 验收标准

- [ ] 成功分析bzip2源码并识别 > 20个问题
- [ ] Clang和Semgrep输出正确解析
- [ ] 问题去重准确
- [ ] 问题分类准确率 > 85%
- [ ] 分析性能：1000行代码 < 10秒
- [ ] 并行分析正常工作

#### 风险与依赖

- **依赖：** 阶段1完成
- **风险：** Clang/Semgrep版本兼容性 → 缓解：版本检测 + 适配器模式

---

### 📌 阶段3：AI增强分析

**⏱ 时间估算：** 5-7天
**🎯 目标：** 集成大语言模型，实现智能分析和建议生成

#### 任务分解

| 任务ID | 任务描述 | 工时 | 依赖 |
|--------|---------|------|------|
| T3.1 | LLM客户端实现（OpenAI/DeepSeek） | 2天 | T1.2 |
| T3.2 | Prompt工程与模板设计 | 2天 | T2.6 |
| T3.3 | AI结果解析与结构化 | 1天 | T3.1 |
| T3.4 | 混合分析决策引擎 | 1.5天 | T3.2, T3.3 |
| T3.5 | 缓存与重试机制 | 0.5天 | T3.1 |

#### 技术方案

**LLM客户端：**
```java
public class LlmClient {

    private final OkHttpClient httpClient;
    private final String apiKey;
    private final String baseUrl;
    private final String model;

    public LlmResponse analyze(String prompt) throws IOException {
        JsonObject requestBody = new JsonObject();
        requestBody.addProperty("model", model);

        JsonArray messages = new JsonArray();
        JsonObject message = new JsonObject();
        message.addProperty("role", "user");
        message.addProperty("content", prompt);
        messages.add(message);

        requestBody.add("messages", messages);
        requestBody.addProperty("temperature", 0.3);
        requestBody.addProperty("max_tokens", 4096);

        // 结构化输出
        JsonObject responseFormat = new JsonObject();
        responseFormat.addProperty("type", "json_object");
        requestBody.add("response_format", responseFormat);

        Request request = new Request.Builder()
            .url(baseUrl + "/chat/completions")
            .header("Authorization", "Bearer " + apiKey)
            .header("Content-Type", "application/json")
            .post(RequestBody.create(
                requestBody.toString(),
                MediaType.get("application/json")
            ))
            .build();

        try (Response response = httpClient.newCall(request).execute()) {
            if (!response.isSuccessful()) {
                throw new IOException("API调用失败: " + response.code());
            }

            String responseBody = response.body().string();
            return ResponseParser.parse(responseBody);
        }
    }
}
```

**Prompt模板：**
```java
public class PromptBuilder {

    public static String buildAnalysisPrompt(SourceFile file, List<Issue> staticIssues) {
        StringBuilder prompt = new StringBuilder();

        prompt.append("你是一位C/C++安全专家。请分析以下代码的安全问题。\n\n");

        prompt.append("## 代码文件：").append(file.getName()).append("\n");
        prompt.append("```c\n");
        prompt.append(file.getContent()).append("\n");
        prompt.append("```\n\n");

        prompt.append("## 静态分析工具发现的问题：\n");
        for (Issue issue : staticIssues) {
            prompt.append(String.format("- [%s] %s (行%d)\n",
                issue.getSeverity(), issue.getTitle(), issue.getLine()));
        }

        prompt.append("\n请提供以下分析（以JSON格式返回）：\n");
        prompt.append("```json\n");
        prompt.append("{\n");
        prompt.append("  \"issues\": [\n");
        prompt.append("    {\n");
        prompt.append("      \"line\": <行号>,\n");
        prompt.append("      \"severity\": \"Critical|High|Medium|Low\",\n");
        prompt.append("      \"category\": \"内存安全|缓冲区溢出|空指针|资源泄漏等\",\n");
        prompt.append("      \"description\": \"详细说明\",\n");
        prompt.append("      \"impact\": \"安全影响分析\",\n");
        prompt.append("      \"suggestion\": \"修复建议\",\n");
        prompt.append("      \"code_fix\": \"修复后的代码示例\"\n");
        prompt.append("    }\n");
        prompt.append("  ],\n");
        prompt.append("  \"overall_assessment\": \"整体安全评估\",\n");
        prompt.append("  \"rust_migration_recommended\": true/false,\n");
        prompt.append("  \"rust_migration_reason\": \"迁移理由\"\n");
        prompt.append("}\n");
        prompt.append("```\n");

        return prompt.toString();
    }

    public static String buildSuggestionPrompt(Issue issue, String codeContext) {
        return String.format("""
            你是一位安全代码重构专家。

            ## 问题：
            类型：%s
            描述：%s
            严重性：%s

            ## 问题代码上下文：
            ```c
            %s
            ```

            请提供：
            1. 详细的安全风险分析
            2. 为什么这是一个问题
            3. 修复后的代码（包含注释说明）
            4. 如何验证修复有效
            5. 是否建议迁移到Rust（如果是，提供原因）

            以JSON格式返回。
            """,
            issue.getType(),
            issue.getTitle(),
            issue.getSeverity(),
            codeContext
        );
    }
}
```

**响应解析器：**
```java
public class ResponseParser {

    private static final Gson gson = new GsonBuilder()
        .setPrettyPrinting()
        .create();

    public static LlmResponse parse(String responseBody) {
        JsonObject root = JsonParser.parseString(responseBody).getAsJsonObject();
        JsonArray choices = root.getAsJsonArray("choices");

        if (choices.size() == 0) {
            throw new ParseException("响应中没有choices");
        }

        JsonObject firstChoice = choices.get(0).getAsJsonObject();
        JsonObject message = firstChoice.getAsJsonObject("message");
        String content = message.get("content").getAsString();

        // 解析JSON内容
        JsonObject analysisResult = JsonParser.parseString(content).getAsJsonObject();

        return LlmResponse.builder()
            .issues(parseIssues(analysisResult.getAsJsonArray("issues")))
            .overallAssessment(analysisResult.get("overall_assessment").getAsString())
            .rustMigrationRecommended(
                analysisResult.get("rust_migration_recommended").getAsBoolean())
            .rustMigrationReason(
                analysisResult.get("rust_migration_reason").getAsString())
            .build();
    }

    private static List<AiIssue> parseIssues(JsonArray issuesArray) {
        List<AiIssue> issues = new ArrayList<>();

        for (JsonElement elem : issuesArray) {
            JsonObject issueObj = elem.getAsJsonObject();

            AiIssue issue = AiIssue.builder()
                .line(issueObj.get("line").getAsInt())
                .severity(Severity.valueOf(issueObj.get("severity").getAsString().toUpperCase()))
                .category(issueObj.get("category").getAsString())
                .description(issueObj.get("description").getAsString())
                .impact(issueObj.get("impact").getAsString())
                .suggestion(issueObj.get("suggestion").getAsString())
                .codeFix(issueObj.get("code_fix").getAsString())
                .build();

            issues.add(issue);
        }

        return issues;
    }
}
```

**混合决策引擎：**
```java
public class DecisionEngine {

    private final SecurityAnalyzer staticAnalyzer;
    private final LlmClient llmClient;

    public EnhancedAnalysisResult analyze(String sourcePath) {
        // 1. 静态分析
        AnalysisResult staticResult = staticAnalyzer.analyze(sourcePath);

        // 2. AI增强分析
        List<SourceFile> files = staticResult.getFiles();
        Map<String, LlmResponse> aiAnalysis = new HashMap<>();

        for (SourceFile file : files) {
            List<Issue> fileIssues = staticResult.getIssuesForFile(file);

            if (!fileIssues.isEmpty()) {
                String prompt = PromptBuilder.buildAnalysisPrompt(file, fileIssues);
                try {
                    LlmResponse response = llmClient.analyze(prompt);
                    aiAnalysis.put(file.getPath(), response);
                } catch (Exception e) {
                    logger.warn("AI分析失败: " + file.getPath(), e);
                }
            }
        }

        // 3. 结果融合
        List<EnhancedIssue> enhancedIssues = mergeResults(staticResult, aiAnalysis);

        // 4. 优先级排序
        enhancedIssues.sort(Comparator
            .comparing(EnhancedIssue::getSeverity)
            .thenComparing(EnhancedIssue::getConfidence)
            .reversed()
        );

        return EnhancedAnalysisResult.builder()
            .issues(enhancedIssues)
            .statistics(computeStatistics(enhancedIssues))
            .recommendations(generateRecommendations(enhancedIssues))
            .build();
    }

    private List<EnhancedIssue> mergeResults(
            AnalysisResult staticResult,
            Map<String, LlmResponse> aiAnalysis) {

        List<EnhancedIssue> enhanced = new ArrayList<>();

        for (Issue staticIssue : staticResult.getIssues()) {
            EnhancedIssue.Builder builder = EnhancedIssue.builder()
                .from(staticIssue)
                .confidence(0.7);  // 静态分析置信度

            // 查找对应的AI分析
            LlmResponse aiResponse = aiAnalysis.get(staticIssue.getFile());
            if (aiResponse != null) {
                Optional<AiIssue> matchingAiIssue = aiResponse.getIssues().stream()
                    .filter(ai -> Math.abs(ai.getLine() - staticIssue.getLine()) <= 2)
                    .findFirst();

                if (matchingAiIssue.isPresent()) {
                    AiIssue aiIssue = matchingAiIssue.get();
                    builder
                        .aiDescription(aiIssue.getDescription())
                        .aiSuggestion(aiIssue.getSuggestion())
                        .codeFix(aiIssue.getCodeFix())
                        .confidence(0.9);  // AI确认的问题置信度更高
                }
            }

            enhanced.add(builder.build());
        }

        return enhanced;
    }
}
```

**缓存机制：**
```java
public class CachedLlmClient extends LlmClient {

    private final Cache<String, LlmResponse> cache;

    public CachedLlmClient(String apiKey, String baseUrl, String model) {
        super(apiKey, baseUrl, model);

        this.cache = CacheBuilder.newBuilder()
            .maximumSize(100)
            .expireAfterWrite(1, TimeUnit.HOURS)
            .build();
    }

    @Override
    public LlmResponse analyze(String prompt) throws IOException {
        String cacheKey = computeHash(prompt);

        LlmResponse cached = cache.getIfPresent(cacheKey);
        if (cached != null) {
            logger.debug("使用缓存结果");
            return cached;
        }

        LlmResponse response = super.analyze(prompt);
        cache.put(cacheKey, response);

        return response;
    }

    private String computeHash(String prompt) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] hash = md.digest(prompt.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
}
```

#### 交付物

- ✅ LlmClient.java（AI接口封装）
- ✅ PromptBuilder.java（Prompt模板库）
- ✅ ResponseParser.java（响应解析器）
- ✅ DecisionEngine.java（混合决策引擎）
- ✅ CachedLlmClient.java（缓存实现）

#### 验收标准

- [ ] 成功调用OpenAI/DeepSeek API
- [ ] AI返回结构化JSON响应
- [ ] AI建议与静态分析结果正确融合
- [ ] API调用成功率 > 95%
- [ ] 响应时间 < 5秒（单次请求）
- [ ] 缓存命中率 > 30%（重复分析）

#### 风险与依赖

- **依赖：** 阶段1、阶段2完成
- **风险：** API限流 → 缓解：重试机制 + 备用API

---

### 📌 阶段4：代码生成与重构 ⚠️

**⏱ 时间估算：** 7-10天
**🎯 目标：** 实现代码修复生成和Rust迁移建议（可降级）

**⚠️ 高风险阶段 - 降级策略：**
- **Phase 1（MVP）：** 仅生成修复建议和示例代码，不自动修改
- **Phase 2（进阶）：** 简单函数自动转换（可选）

#### 任务分解

| 任务ID | 任务描述 | 工时 | 优先级 |
|--------|---------|------|--------|
| T4.1 | 代码修复建议生成 | 2天 | P0 |
| T4.2 | C→Rust迁移建议生成 | 2天 | P0 |
| T4.3 | 代码模式匹配与替换 | 2天 | P1 |
| T4.4 | Rust代码语法验证 | 1天 | P2 |
| T4.5 | 简单函数自动转换（可选） | 3天 | P2 |

#### 技术方案（Phase 1 - MVP）

**代码修复建议生成：**
```java
public class CodeGenerator {

    private final LlmClient llmClient;

    public FixSuggestion generateFixSuggestion(Issue issue, String codeContext) {
        String prompt = PromptBuilder.buildFixPrompt(issue, codeContext);

        try {
            LlmResponse response = llmClient.analyze(prompt);

            return FixSuggestion.builder()
                .issue(issue)
                .originalCode(codeContext)
                .fixedCode(response.getFixedCode())
                .explanation(response.getExplanation())
                .confidence(response.getConfidence())
                .steps(response.getSteps())
                .build();
        } catch (Exception e) {
            logger.error("生成修复建议失败", e);
            return FixSuggestion.fallback(issue);
        }
    }
}
```

**Rust迁移建议：**
```java
public class RustMigrationAdvisor {

    private final LlmClient llmClient;

    public MigrationSuggestion suggestMigration(SourceFile file, List<Issue> issues) {
        String prompt = PromptBuilder.buildRustMigrationPrompt(file, issues);

        LlmResponse response = llmClient.analyze(prompt);

        return MigrationSuggestion.builder()
            .sourceFile(file)
            .recommended(response.isRustMigrationRecommended())
            .reason(response.getRustMigrationReason())
            .exampleRustCode(response.getRustCodeExample())
            .migrationSteps(response.getMigrationSteps())
            .estimatedEffort(response.getEstimatedEffort())
            .benefits(response.getBenefits())
            .challenges(response.getChallenges())
            .build();
    }
}
```

**Prompt模板：**
```java
public static String buildRustMigrationPrompt(SourceFile file, List<Issue> issues) {
    return String.format("""
        你是Rust语言专家和C/C++代码迁移顾问。

        ## C代码文件：%s
        ```c
        %s
        ```

        ## 安全问题：
        %s

        请提供Rust迁移建议（JSON格式）：
        {
          "recommended": true/false,
          "reason": "迁移理由或不建议理由",
          "rust_code_example": "关键部分的Rust代码示例",
          "migration_steps": [
            "步骤1: ...",
            "步骤2: ..."
          ],
          "type_mappings": {
            "char*": "String 或 &str",
            "int": "i32"
          },
          "memory_management_changes": "说明内存管理的变化",
          "estimated_effort": "Low|Medium|High",
          "benefits": ["益处1", "益处2"],
          "challenges": ["挑战1", "挑战2"]
        }
        """,
        file.getName(),
        file.getContent(),
        formatIssues(issues)
    );
}
```

#### 交付物

- ✅ CodeGenerator.java（修复建议生成）
- ✅ RustMigrationAdvisor.java（迁移建议）
- ✅ PromptBuilder增强（修复和迁移模板）
- ✅ 10+个测试用例

#### 验收标准（Phase 1）

- [ ] 成功生成代码修复建议
- [ ] 修复建议包含代码示例和步骤
- [ ] Rust迁移建议合理且详细
- [ ] 类型映射准确
- [ ] 示例代码语法正确

#### 风险与依赖

- **依赖：** 阶段3完成
- **风险：** 代码转换语义不等价 → 缓解：仅生成建议，不自动修改
- **降级触发：** 时间不足或准确率低

---

### 📌 阶段5：报告生成与可视化

**⏱ 时间估算：** 3-4天
**🎯 目标：** 生成专业的安全分析报告

#### 任务分解

| 任务ID | 任务描述 | 工时 | 依赖 |
|--------|---------|------|------|
| T5.1 | HTML报告模板设计 | 1天 | - |
| T5.2 | Markdown报告模板 | 0.5天 | - |
| T5.3 | 报告生成引擎 | 1天 | T5.1, T5.2 |
| T5.4 | 数据可视化（图表） | 1天 | T5.3 |
| T5.5 | JSON导出功能 | 0.5天 | T5.3 |

#### 技术方案

**报告生成器：**
```java
public class ReportGenerator {

    private final Configuration freemarkerConfig;

    public void generateHtmlReport(EnhancedAnalysisResult result, String outputPath)
            throws IOException, TemplateException {

        Template template = freemarkerConfig.getTemplate("report.ftlh");

        Map<String, Object> data = new HashMap<>();
        data.put("projectName", result.getProjectName());
        data.put("analysisDate", LocalDateTime.now());
        data.put("issues", result.getIssues());
        data.put("statistics", result.getStatistics());
        data.put("recommendations", result.getRecommendations());
        data.put("chartData", prepareChartData(result));

        try (Writer writer = new FileWriter(outputPath)) {
            template.process(data, writer);
        }

        logger.info("HTML报告已生成: " + outputPath);
    }

    public void generateMarkdownReport(EnhancedAnalysisResult result, String outputPath)
            throws IOException {

        StringBuilder md = new StringBuilder();

        md.append("# ").append(result.getProjectName()).append(" 安全分析报告\n\n");
        md.append("**分析时间：** ").append(LocalDateTime.now()).append("\n\n");

        // 概览
        md.append("## 📊 概览\n\n");
        Statistics stats = result.getStatistics();
        md.append("- 总问题数：").append(stats.getTotalIssues()).append("\n");
        md.append("- 严重问题：").append(stats.getCriticalCount()).append("\n");
        md.append("- 高危问题：").append(stats.getHighCount()).append("\n");
        md.append("- 中危问题：").append(stats.getMediumCount()).append("\n\n");

        // 问题详情
        md.append("## ⚠️ 问题详情\n\n");
        for (EnhancedIssue issue : result.getIssues()) {
            md.append("### ").append(issue.getTitle()).append("\n\n");
            md.append("- **文件：** ").append(issue.getFile()).append(":").append(issue.getLine()).append("\n");
            md.append("- **严重性：** ").append(issue.getSeverity()).append("\n");
            md.append("- **类别：** ").append(issue.getCategory()).append("\n\n");
            md.append("**描述：** ").append(issue.getDescription()).append("\n\n");

            if (issue.getAiSuggestion() != null) {
                md.append("**修复建议：** ").append(issue.getAiSuggestion()).append("\n\n");
            }

            if (issue.getCodeFix() != null) {
                md.append("**修复代码：**\n```c\n");
                md.append(issue.getCodeFix()).append("\n```\n\n");
            }

            md.append("---\n\n");
        }

        Files.writeString(Paths.get(outputPath), md.toString());
        logger.info("Markdown报告已生成: " + outputPath);
    }
}
```

**HTML模板（Freemarker）：**
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${projectName} - 安全分析报告</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 40px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        h1 { color: #333; border-bottom: 3px solid #007bff; padding-bottom: 10px; }
        h2 { color: #555; margin-top: 30px; }
        .statistics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .stat-card {
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            color: white;
        }
        .stat-card.critical { background: #dc3545; }
        .stat-card.high { background: #fd7e14; }
        .stat-card.medium { background: #ffc107; color: #333; }
        .stat-card.low { background: #17a2b8; }
        .stat-card h3 { margin: 0; font-size: 2em; }
        .stat-card p { margin: 5px 0 0; }

        .issue {
            border-left: 4px solid;
            padding: 15px;
            margin: 20px 0;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .issue.critical { border-left-color: #dc3545; }
        .issue.high { border-left-color: #fd7e14; }
        .issue.medium { border-left-color: #ffc107; }
        .issue.low { border-left-color: #17a2b8; }

        .issue h3 { margin-top: 0; color: #333; }
        .issue-meta { color: #666; font-size: 0.9em; margin: 5px 0; }
        .code-block {
            background: #282c34;
            color: #abb2bf;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 10px 0;
        }
        .suggestion {
            background: #e7f3ff;
            border-left: 4px solid #007bff;
            padding: 10px;
            margin: 10px 0;
        }
        .chart-container {
            position: relative;
            height: 400px;
            margin: 30px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>📊 ${projectName} 安全分析报告</h1>
        <p><strong>分析时间：</strong> ${analysisDate?string('yyyy-MM-dd HH:mm:ss')}</p>

        <h2>📈 统计概览</h2>
        <div class="statistics">
            <div class="stat-card critical">
                <h3>${statistics.criticalCount}</h3>
                <p>严重问题</p>
            </div>
            <div class="stat-card high">
                <h3>${statistics.highCount}</h3>
                <p>高危问题</p>
            </div>
            <div class="stat-card medium">
                <h3>${statistics.mediumCount}</h3>
                <p>中危问题</p>
            </div>
            <div class="stat-card low">
                <h3>${statistics.lowCount}</h3>
                <p>低危问题</p>
            </div>
        </div>

        <div class="chart-container">
            <canvas id="severityChart"></canvas>
        </div>

        <div class="chart-container">
            <canvas id="categoryChart"></canvas>
        </div>

        <h2>⚠️ 问题详情</h2>
        <#list issues as issue>
        <div class="issue ${issue.severity?lower_case}">
            <h3>${issue.title}</h3>
            <div class="issue-meta">
                <span>📁 ${issue.file}:${issue.line}</span> |
                <span>🔴 ${issue.severity}</span> |
                <span>📂 ${issue.category}</span>
            </div>

            <p><strong>描述：</strong>${issue.description}</p>

            <#if issue.code??>
            <div class="code-block">
                <pre><code>${issue.code}</code></pre>
            </div>
            </#if>

            <#if issue.aiSuggestion??>
            <div class="suggestion">
                <strong>💡 AI建议：</strong>${issue.aiSuggestion}
            </div>
            </#if>

            <#if issue.codeFix??>
            <p><strong>🔧 修复代码：</strong></p>
            <div class="code-block">
                <pre><code>${issue.codeFix}</code></pre>
            </div>
            </#if>
        </div>
        </#list>

        <h2>📝 改进建议</h2>
        <#list recommendations as rec>
        <div class="suggestion">
            <strong>${rec.title}</strong>
            <p>${rec.description}</p>
        </div>
        </#list>
    </div>

    <script>
        // 严重性分布图表
        const severityCtx = document.getElementById('severityChart');
        new Chart(severityCtx, {
            type: 'doughnut',
            data: {
                labels: ['严重', '高危', '中危', '低危'],
                datasets: [{
                    data: [
                        ${statistics.criticalCount},
                        ${statistics.highCount},
                        ${statistics.mediumCount},
                        ${statistics.lowCount}
                    ],
                    backgroundColor: ['#dc3545', '#fd7e14', '#ffc107', '#17a2b8']
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: { display: true, text: '问题严重性分布' }
                }
            }
        });

        // 类别分布图表
        const categoryCtx = document.getElementById('categoryChart');
        new Chart(categoryCtx, {
            type: 'bar',
            data: {
                labels: [<#list chartData.categories as cat>'${cat}'<#sep>, </#list>],
                datasets: [{
                    label: '问题数量',
                    data: [<#list chartData.counts as count>${count}<#sep>, </#list>],
                    backgroundColor: '#007bff'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: { display: true, text: '问题类别分布' }
                },
                scales: {
                    y: { beginAtZero: true }
                }
            }
        });
    </script>
</body>
</html>
```

#### 交付物

- ✅ ReportGenerator.java
- ✅ HTML模板（report.ftlh）
- ✅ Markdown模板
- ✅ CSS样式文件
- ✅ 图表集成

#### 验收标准

- [ ] 生成的HTML报告美观且信息完整
- [ ] Markdown报告在GitHub正确渲染
- [ ] 图表正确显示数据
- [ ] JSON格式可被其他工具解析
- [ ] 报告生成时间 < 2秒

#### 风险与依赖

- **依赖：** 阶段3或阶段4完成
- **风险：** 低

---

### 📌 阶段6：性能优化与测试

**⏱ 时间估算：** 4-5天
**🎯 目标：** 优化性能，建立完整的测试体系

#### 任务分解

| 任务ID | 任务描述 | 工时 | 依赖 |
|--------|---------|------|------|
| T6.1 | 并行分析优化 | 1天 | T2.6 |
| T6.2 | 增量分析实现 | 1天 | T2.6 |
| T6.3 | 单元测试编写 | 1.5天 | 所有模块 |
| T6.4 | 集成测试与E2E测试 | 1天 | 所有模块 |
| T6.5 | 性能基准测试 | 0.5天 | T6.1, T6.2 |

#### 技术方案

**增量分析：**
```java
public class IncrementalAnalyzer {

    private final Cache<String, AnalysisResult> cache;
    private final Path cacheDir;

    public AnalysisResult analyze(String sourcePath, boolean incremental) {
        if (!incremental) {
            return fullAnalysis(sourcePath);
        }

        // 1. 计算文件哈希
        Map<String, FileHash> currentHashes = computeFileHashes(sourcePath);
        Map<String, FileHash> cachedHashes = loadCachedHashes(sourcePath);

        // 2. 识别变更文件
        List<SourceFile> changedFiles = new ArrayList<>();
        for (Map.Entry<String, FileHash> entry : currentHashes.entrySet()) {
            FileHash cached = cachedHashes.get(entry.getKey());
            if (cached == null || !cached.equals(entry.getValue())) {
                changedFiles.add(new SourceFile(entry.getKey()));
            }
        }

        if (changedFiles.isEmpty()) {
            logger.info("没有文件变更，使用缓存结果");
            return loadCachedResult(sourcePath);
        }

        logger.info("检测到 {} 个文件变更，进行增量分析", changedFiles.size());

        // 3. 仅分析变更文件
        AnalysisResult incrementalResult = analyzeFiles(changedFiles);

        // 4. 合并缓存结果
        AnalysisResult cachedResult = loadCachedResult(sourcePath);
        AnalysisResult merged = mergeResults(cachedResult, incrementalResult, changedFiles);

        // 5. 更新缓存
        saveCachedHashes(sourcePath, currentHashes);
        saveCachedResult(sourcePath, merged);

        return merged;
    }

    private Map<String, FileHash> computeFileHashes(String sourcePath) throws IOException {
        Map<String, FileHash> hashes = new HashMap<>();
        MessageDigest md = MessageDigest.getInstance("SHA-256");

        Files.walk(Paths.get(sourcePath))
            .filter(Files::isRegularFile)
            .filter(this::isSupportedFile)
            .forEach(path -> {
                try {
                    byte[] content = Files.readAllBytes(path);
                    byte[] hash = md.digest(content);
                    hashes.put(path.toString(), new FileHash(hash, content.length));
                } catch (IOException e) {
                    logger.warn("无法读取文件: " + path, e);
                }
            });

        return hashes;
    }
}
```

**性能监控：**
```java
public class PerformanceMonitor {

    private final Map<String, Timer> timers = new ConcurrentHashMap<>();

    public void startTimer(String operation) {
        timers.put(operation, Timer.start());
    }

    public long stopTimer(String operation) {
        Timer timer = timers.remove(operation);
        if (timer == null) {
            logger.warn("Timer not found: " + operation);
            return 0;
        }

        long duration = timer.stop();
        logger.info("⏱️  {} 耗时: {}ms", operation, duration);

        return duration;
    }

    public void recordMetrics(AnalysisResult result, long duration) {
        Metrics metrics = Metrics.builder()
            .filesAnalyzed(result.getFileCount())
            .issuesFound(result.getIssueCount())
            .duration(duration)
            .linesOfCode(result.getTotalLines())
            .throughput(result.getTotalLines() / (duration / 1000.0))
            .build();

        logger.info("📊 性能指标: {}", metrics);
    }
}
```

**单元测试示例：**
```java
@Test
public void testSecurityAnalyzer_detectsBufferOverflow() {
    // Arrange
    SecurityAnalyzer analyzer = new SecurityAnalyzer();
    String testCode = """
        void test() {
            char buf[10];
            strcpy(buf, "this is too long");  // 缓冲区溢出
        }
        """;

    // Act
    AnalysisResult result = analyzer.analyze(testCode);

    // Assert
    assertFalse(result.getIssues().isEmpty());

    Issue issue = result.getIssues().get(0);
    assertEquals("BUFFER_OVERFLOW", issue.getType());
    assertEquals(Severity.CRITICAL, issue.getSeverity());
    assertTrue(issue.getTitle().contains("strcpy"));
}

@Test
public void testIncrementalAnalyzer_skipUnchangedFiles() {
    // Arrange
    IncrementalAnalyzer analyzer = new IncrementalAnalyzer();
    String sourcePath = "test/fixtures/bzip2";

    // Act - 首次分析
    AnalysisResult firstRun = analyzer.analyze(sourcePath, true);

    // Act - 第二次分析（无变更）
    AnalysisResult secondRun = analyzer.analyze(sourcePath, true);

    // Assert
    assertEquals(firstRun.getIssues(), secondRun.getIssues());
    // 第二次应该使用缓存，速度更快
}
```

#### 交付物

- ✅ IncrementalAnalyzer.java
- ✅ PerformanceMonitor.java
- ✅ 单元测试套件（覆盖率 > 80%）
- ✅ 集成测试用例
- ✅ 性能基准报告

#### 验收标准

- [ ] 分析bzip2性能 < 30秒
- [ ] 增量分析速度提升 > 60%
- [ ] 单元测试覆盖率 > 80%
- [ ] 所有测试通过
- [ ] 内存使用 < 512MB

#### 风险与依赖

- **依赖：** 所有前置阶段
- **风险：** 低

---

### 📌 阶段7：容器化与部署

**⏱ 时间估算：** 2-3天
**🎯 目标：** Docker容器化，编写文档，准备Demo

#### 任务分解

| 任务ID | 任务描述 | 工时 | 依赖 |
|--------|---------|------|------|
| T7.1 | Dockerfile编写与优化 | 1天 | T6.5 |
| T7.2 | 用户文档编写 | 1天 | - |
| T7.3 | Demo准备与视频录制 | 1天 | T6.5 |

#### 技术方案

**Dockerfile：**
```dockerfile
# 多阶段构建
FROM maven:3.9-eclipse-temurin-17 AS builder

WORKDIR /app

# 复制依赖文件
COPY pom.xml .
RUN mvn dependency:go-offline

# 复制源码并构建
COPY src ./src
RUN mvn clean package -DskipTests

# 运行时镜像
FROM eclipse-temurin:17-jre-alpine

# 安装分析工具
RUN apk add --no-cache \
    clang \
    python3 \
    py3-pip \
    && pip3 install semgrep \
    && rm -rf /var/cache/apk/*

WORKDIR /app

# 复制构建产物
COPY --from=builder /app/target/harmony-agent.jar .
COPY --from=builder /app/src/main/resources/rules ./rules

# 配置环境变量
ENV JAVA_OPTS="-Xmx512m"
ENV HARMONY_AGENT_HOME="/app"

# 创建挂载点
VOLUME ["/workspace", "/app/config"]

ENTRYPOINT ["java", "-jar", "harmony-agent.jar"]
CMD ["--help"]
```

**Docker Compose：**
```yaml
version: '3.8'

services:
  harmony-agent:
    build: .
    image: harmony-agent:latest
    volumes:
      - ./workspace:/workspace
      - ./config:/app/config
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    command: analyze /workspace/bzip2
```

**文档结构：**
```
docs/
├── README.md              # 项目概述与快速开始
├── installation.md        # 安装指南
│   ├── Native安装
│   ├── Docker安装
│   └── 依赖工具安装
├── user-guide.md         # 用户手册
│   ├── analyze命令
│   ├── suggest命令
│   ├── refactor命令
│   ├── report命令
│   └── config命令
├── configuration.md      # 配置说明
│   ├── 配置文件格式
│   ├── AI API配置
│   ├── 分析级别
│   └── 输出格式
├── architecture.md       # 架构设计
│   ├── 系统架构
│   ├── 模块说明
│   └── 技术栈
├── api-reference.md      # API参考（Java API）
├── semgrep-rules.md      # Semgrep规则文档
├── troubleshooting.md    # 故障排查
└── examples/
    ├── bzip2-analysis.md    # bzip2分析示例
    ├── custom-rules.md      # 自定义规则示例
    └── ci-integration.md    # CI/CD集成示例
```

**快速开始文档：**
```markdown
# HarmonySafeAgent

> OpenHarmony代码安全分析工具 - 自动化安全检测与改进建议

## ✨ 特性

- 🔍 **静态分析**：集成Clang和Semgrep，识别内存安全、并发等问题
- 🤖 **AI增强**：利用大语言模型提供上下文相关的修复建议
- 🦀 **Rust迁移**：辅助C/C++代码向Rust迁移
- 📊 **可视化报告**：生成专业的HTML/Markdown安全报告
- ⚡ **增量分析**：仅分析变更文件，提升效率

## 🚀 快速开始

### Docker方式（推荐）

```bash
# 1. 设置API密钥
export OPENAI_API_KEY=sk-xxxxx

# 2. 运行分析
docker run -v $(pwd):/workspace \
  -e OPENAI_API_KEY=$OPENAI_API_KEY \
  harmony-agent:latest \
  analyze /workspace/bzip2

# 3. 生成报告
docker run -v $(pwd):/workspace \
  harmony-agent:latest \
  report /workspace/bzip2 -f html -o /workspace/report.html
```

### Native方式

```bash
# 1. 安装依赖
# macOS
brew install clang semgrep

# Ubuntu
apt-get install clang
pip install semgrep

# 2. 配置API密钥
java -jar harmony-agent.jar config set ai.api_key sk-xxxxx

# 3. 运行分析
java -jar harmony-agent.jar analyze ./bzip2

# 4. 查看建议
java -jar harmony-agent.jar suggest ./bzip2

# 5. 生成报告
java -jar harmony-agent.jar report ./bzip2 -f html
```

## 📖 文档

- [完整用户手册](docs/user-guide.md)
- [配置说明](docs/configuration.md)
- [架构设计](docs/architecture.md)
- [故障排查](docs/troubleshooting.md)

## 🎯 使用示例

### 分析bzip2源码

```bash
# 深度分析
harmony-agent analyze ./bzip2 --level deep

# 输出：
✅ 分析完成
📊 发现 42 个安全问题
  - 严重: 8
  - 高危: 15
  - 中危: 12
  - 低危: 7

🔍 主要问题类别:
  - 缓冲区溢出: 12
  - 内存泄漏: 8
  - 空指针解引用: 6
  - 未初始化变量: 5
```

### 获取AI建议

```bash
harmony-agent suggest ./bzip2/bzlib.c

# 输出：
💡 AI建议：bzlib.c:234

问题：strcpy可能导致缓冲区溢出
严重性：Critical
置信度：0.93

修复建议：
使用strncpy或snprintf替代strcpy，并确保字符串正确终止。

修复代码：
strncpy(dest, src, sizeof(dest) - 1);
dest[sizeof(dest) - 1] = '\0';

Rust迁移建议：
建议迁移到Rust，使用String类型自动管理内存。
```

## 🏗️ 架构

```
CLI层 → 核心引擎 → AI推理层
                 → 工具链层 (Clang/Semgrep)
```

## 📝 许可证

MIT License
```

#### 交付物

- ✅ Dockerfile（优化后 < 500MB）
- ✅ Docker Compose配置
- ✅ 完整用户文档
- ✅ bzip2分析Demo
- ✅ Demo演示视频

#### 验收标准

- [ ] Docker镜像成功构建并运行
- [ ] 镜像大小 < 500MB
- [ ] 文档清晰完整
- [ ] Demo展示完整功能流程
- [ ] 视频长度 5-10分钟

#### 风险与依赖

- **依赖：** 所有前置阶段
- **风险：** 低

---

## ⚠️ 技术风险管理

### 风险矩阵

| 风险ID | 描述 | 影响 | 概率 | 缓解策略 | 触发条件 |
|--------|------|------|------|---------|---------|
| **R1** | Clang/Semgrep输出格式变化 | 🔴 High | 30% | 版本锁定 + 适配器模式 | 工具版本升级 |
| **R2** | C→Rust转换语义不等价 | 🔴 Critical | 60% | **降级到Phase 1：仅建议** | 准确率 < 70% |
| **R3** | AI API限流/失败 | 🟡 Medium | 40% | 重试 + 降级到静态分析 | API错误率 > 5% |
| **R4** | 大型项目性能问题 | 🟡 Medium | 50% | 增量分析 + 并行处理 | 分析时间 > 5分钟 |
| **R5** | API密钥泄露风险 | 🔴 High | 20% | AES-256加密 + 权限控制 | 配置文件暴露 |
| **R6** | AST解析复杂度超预期 | 🟡 Medium | 40% | **降级到模式匹配** | 实现时间 > 3天 |
| **R7** | 跨平台兼容性问题 | 🟢 Low | 30% | Java NIO + 路径标准化 | Windows测试失败 |
| **R8** | 依赖工具未安装 | 🟡 Medium | 50% | 启动检查 + Docker方案 | 环境验证失败 |

### 降级策略

#### R2: C→Rust转换风险（最高优先级）

**Phase 1（MVP） - 当前阶段：**
- ✅ 生成Rust迁移建议和示例代码
- ✅ 不自动修改原代码
- ✅ 提供类型映射和迁移步骤
- 📊 风险：低
- ⏱️  时间：4天

**Phase 2（可选）：**
- ⚠️  简单函数自动转换
- ⚠️  需要100+测试用例验证
- 📊 风险：高
- ⏱️  额外时间：+3天

**触发Phase 2条件：**
- 前置阶段提前完成
- 有额外3天以上时间
- 测试准确率 > 80%

**降级触发：**
- 准确率 < 70%
- 时间不足
- 语义验证失败

---

## 📈 里程碑与交付计划

### 关键里程碑

| 里程碑 | 日期（相对） | 交付物 | 成功标准 |
|--------|-------------|--------|---------|
| **M0: 项目启动** | Day 0 | 项目骨架、环境配置 | 构建成功，POC通过 |
| **M1: CLI框架完成** | Day 7 | 可执行的CLI工具 | 所有命令可用 |
| **M2: 静态分析可用** | Day 15 | 集成Clang和Semgrep | 分析bzip2成功 |
| **M3: AI增强完成** | Day 22 | AI建议生成 | AI API成功率 > 95% |
| **M4: 核心功能完成** | Day 32 | MVP版本 | 所有P0功能完成 |
| **M5: 性能优化完成** | Day 37 | 优化版本 | 性能达标 |
| **M6: 项目交付** | Day 40 | 完整系统 + 文档 + Demo | 验收通过 |

### 每周交付计划

**Week 1（Day 1-7）：** 基础框架
- ✅ 项目初始化
- ✅ CLI框架
- ✅ 配置管理
- 📦 交付：可运行的CLI工具

**Week 2（Day 8-14）：** 静态分析
- ✅ 代码扫描
- ✅ Clang集成
- ✅ Semgrep集成
- 📦 交付：静态分析引擎

**Week 3（Day 15-21）：** AI增强
- ✅ LLM客户端
- ✅ Prompt工程
- ✅ 混合决策
- 📦 交付：AI增强分析

**Week 4（Day 22-28）：** 代码生成
- ✅ 修复建议生成
- ✅ Rust迁移建议
- 📦 交付：代码生成模块

**Week 5（Day 29-35）：** 报告与优化
- ✅ 报告生成
- ✅ 性能优化
- ✅ 测试完善
- 📦 交付：优化版本

**Week 6（Day 36-40）：** 部署与交付
- ✅ Docker容器化
- ✅ 文档编写
- ✅ Demo准备
- 📦 交付：完整系统

---

## 📊 进度跟踪

### KPI指标

| 指标 | 目标 | 监控方式 |
|------|------|---------|
| 功能完成度 | > 95% P0功能 | 需求跟踪表 |
| 代码质量 | 测试覆盖率 > 80% | JaCoCo报告 |
| 性能达标率 | 100% | 基准测试 |
| 文档完整性 | 100% | 文档清单 |
| Demo准备度 | 100% | 功能演示 |

### 质量门禁

**阶段完成标准：**
- [ ] 所有验收标准通过
- [ ] 单元测试覆盖率 > 80%
- [ ] 代码审查完成
- [ ] 功能演示通过
- [ ] 文档更新完成

**项目交付标准：**
- [ ] 所有P0功能完成
- [ ] P1功能 > 80%完成
- [ ] 性能指标达标
- [ ] 文档完整
- [ ] Demo可演示
- [ ] Docker镜像可用

---

## 🎯 资源规划

### 人力需求

| 角色 | 工作量 | 主要职责 |
|------|--------|---------|
| 核心开发者 | 全职 | 架构设计、核心模块开发 |
| 测试工程师 | 兼职（Week 5-6） | 测试用例编写、质量保证 |
| 文档工程师 | 兼职（Week 6） | 用户文档、技术文档 |

### 工具与资源

| 资源 | 用途 | 成本 |
|------|------|------|
| OpenAI API | AI分析 | $50-100 |
| 开发环境 | Java 17, Maven, Docker | 免费 |
| CI/CD | GitHub Actions | 免费 |
| 文档平台 | Markdown + GitHub Pages | 免费 |

---

## 🔍 质量保证策略

### 测试策略

**单元测试（覆盖率 > 80%）：**
- CLI命令解析测试
- 配置管理测试
- 静态分析引擎测试
- AI客户端测试
- 报告生成测试

**集成测试：**
- CLI → 分析引擎 → 报告生成
- 静态分析 → AI分析 → 决策引擎
- 增量分析流程

**E2E测试：**
- bzip2完整分析流程
- 报告生成流程
- Docker容器运行

**性能测试：**
- 1K LOC分析时间
- 10K LOC分析时间
- 100K LOC增量分析时间
- 内存使用测试

### 代码审查

**审查清单：**
- [ ] 代码风格符合规范
- [ ] 异常处理完善
- [ ] 日志记录合理
- [ ] 性能无明显问题
- [ ] 安全隐患排查
- [ ] 测试覆盖充分

---

## 📚 附录

### A. 技术栈清单

| 类别 | 技术 | 版本 | 用途 |
|------|------|------|------|
| 语言 | Java | 17 | 主要开发语言 |
| 构建 | Maven | 3.9+ | 依赖管理与构建 |
| CLI | Picocli | 4.7.5 | 命令行框架 |
| HTTP | OkHttp | 4.12.0 | AI API调用 |
| JSON | Gson | 2.10.1 | JSON处理 |
| 模板 | Freemarker | 2.3.32 | 报告模板 |
| 日志 | Logback | 1.4.14 | 日志框架 |
| 测试 | JUnit 5 | 5.10.1 | 单元测试 |
| 静态分析 | Clang | 14+ | C/C++分析 |
| 静态分析 | Semgrep | latest | 规则引擎 |
| 容器 | Docker | 20+ | 容器化部署 |

### B. 配置示例

详见阶段1技术方案中的`config.yml`示例。

### C. 参考资源

- [Picocli文档](https://picocli.info/)
- [Clang静态分析器](https://clang.llvm.org/docs/ClangStaticAnalyzer.html)
- [Semgrep文档](https://semgrep.dev/docs/)
- [OpenAI API文档](https://platform.openai.com/docs/)
- [Freemarker文档](https://freemarker.apache.org/)

---

## 📝 变更记录

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|---------|------|
| 1.0 | 2025-10-XX | 初始版本 | Original |
| 2.0 | 2025-10-17 | 详细阶段规划，风险管理，降级策略 | Claude |

---

**本文档为详细的阶段性开发计划书，基于原始需求分析制定。建议根据实际开发进度动态调整。**
